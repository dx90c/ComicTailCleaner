好的，完全理解您的要求。我將使用繁體中文，並嚴格遵循您提供的分段策略。

這是一份為新的 AI 協作者準備的、清晰完整的專案交接文件。

專案交接文件：ComicTailCleaner 開發計畫與狀態

致新的 AI 協作者：

您好，我將與您協作，繼續 ComicTailCleaner 專案的開發。為使您快速進入狀態，以下是本專案的開發路線圖、當前版本 (v12.7.0) 的詳細實現計畫，以及我們為應對輸出限制而制定的程式碼分段策略。

一、開發路線圖 (v12.6.0 及以後)

我們已經完成了 v12.6.x 系列的開發，其核心目標是提升穩定性與使用者體驗。目前，我們正準備啟動 v12.7.0 的開發。

v12.6.0 (已完成)

核心目標：改善新使用者體驗和 QR 掃描性能。

已實現：

智慧依賴檢查：自動檢測並提供一鍵安裝核心依賴的選項；對可選依賴則僅禁用相關功能而非退出。

QR 掃描性能優化：引入「縮圖掃描」技術，大幅提升高解析度圖片的掃描速度。

v12.6.1 - v12.6.3 (已完成)

核心目標：全面的 Bug 修復與健壯性增強。

已實現：

修復了 save_config 中的關鍵 Bug。

強化了依賴檢查和自動安裝的邏輯。

引入了「二次掃描」（縮圖失敗後使用原圖）策略，平衡 QR 掃描的速度與準確性。

修復了多進程安全問題（進程池清理、快取檔案鎖）。

修復了多個 UI Bug（方向鍵導航、選取建議、輸入驗證等）。

v12.7.0 (當前開發目標)

核心目標：解決大規模資料集下的 UI 響應性問題。

待實現：

分頁加載 (Pagination)：Treeview 結果列表將分批載入，實現「無限滾動」。

異步圖片預覽 (Asynchronous Preview)：圖片預覽將在背景執行緒載入，防止 UI 凍結。

v12.8.0 / v13.0.0 (未來長期目標)

核心目標：引入更高級的功能。

待實現：

錯誤恢復與中斷點續傳：允許使用者從上次意外中斷的地方繼續掃描。

多重哈希驗證：同時使用 pHash 和 whash 進一步提升比對準確性。

二、v12.7.0 實現細節

v12.7.0 的核心是重構 MainWindow 類，以實現 UI 性能優化。

1. 分頁加載 (Pagination)

目標：當掃描結果群組數 > 100 時，Treeview 不再一次性載入所有條目。

實現細節：

在 MainWindow.__init__ 中增加分頁狀態變數：self.sorted_groups = [], self.current_page = 0, self.page_size = 100, self.is_loading_page = False。

重構 _populate_treeview 為 _process_scan_results，它只負責預處理資料和啟動第一頁的載入。

創建一個新的 _populate_treeview_page 方法，負責將 self.sorted_groups 中指定範圍（由 self.current_page 和 self.page_size 決定）的資料渲染到 Treeview。

為 Treeview 的垂直捲動條綁定 _on_scroll 事件。

創建 _on_scroll 方法，當偵測到捲動條接近底部 (e.g., yview()[1] > 0.95) 且不在載入狀態時，呼叫 _load_next_page。

創建 _load_next_page 方法，它會增加 self.current_page 的計數，並呼叫 _populate_treeview_page 追加新一頁的資料。

2. 異步圖片預覽

目標：使用者在 Treeview 中選擇項目時，圖片載入過程不阻塞 UI 主執行緒。

實現細節：

在 MainWindow.__init__ 中初始化一個 ThreadPoolExecutor 和一個專用於預覽的 self.preview_queue。

修改原有的 check_queue 方法為 _check_queues，使其同時處理 scan_queue 和 preview_queue。

重構 _load_and_display_selected_image 方法，將其更名為 _trigger_async_preview。此方法不再直接載入圖片，而是：

向預覽框顯示「載入中...」文本。

將圖片載入任務（路徑、是否為目標圖等資訊）提交給 ThreadPoolExecutor。

創建一個新的執行緒工作函式 _load_image_worker，它負責在背景執行緒中執行耗時的 Image.open 和 _draw_qr_outline 操作，並將結果（圖片物件、路徑、載入時間等）放入 self.preview_queue。

_check_queues 方法會定期從預覽隊列中獲取結果，並在主執行緒中安全地更新 self.pil_img_target 等變數和呼叫 _resize_and_display 來更新 UI。

在 _on_closing 方法中，確保安全地呼叫 self.executor.shutdown() 來釋放執行緒池資源。

三、程式碼分段策略

為避免因輸出限制導致的上下文丟失和程式碼不完整問題，請嚴格遵守以下分段策略提供程式碼：

第一部分：非 GUI 核心程式碼

內容: 包含從檔案頭到 ImageComparisonEngine 類別結束的所有內容。涵蓋 Sections 1-9。

結束標誌: class ImageComparisonEngine: 的最後一個方法之後。

第二部分：GUI 類別 (除 MainWindow)

內容: 包含 Tooltip 類別和 SettingsGUI 類別的完整定義。

結束標誌: class SettingsGUI: 的最後一個方法之後。

第三部分：主視窗類別 (MainWindow) 與程式入口

內容: 包含完整的 MainWindow 類別、main() 函式和 if __name__ == '__main__': 區塊。

結束標誌: 檔案末尾。

請在每一部分的末尾，使用以下格式明確指出尚未提供的部分，以便於追蹤：

Generated code
# === 尚未提供的部分 ===
# - [下一部分的標題，例如：GUI 類別 (除 MainWindow)]
# - [再下一個部分的標題，例如：主視窗類別 (MainWindow) 與程式入口]
